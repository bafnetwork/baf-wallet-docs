(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[358],{9557:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c},default:function(){return p}});var a=t(2122),i=t(9756),r=(t(7294),t(3905)),s={sidebar_position:1},o={unversionedId:"libs/interfaces",id:"libs/interfaces",isDocsHomePage:!1,title:"Interfaces",description:"Purpose",source:"@site/docs/libs/interfaces.md",sourceDirName:"libs",slug:"/libs/interfaces",permalink:"/baf-wallet-docs/docs/libs/interfaces",editUrl:"https://github.com/bafnetwork/baf-wallet-v2/tree/main/docs/docs/libs/interfaces.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Contributing",permalink:"/baf-wallet-docs/docs/contributing"},next:{title:"frontend",permalink:"/baf-wallet-docs/docs/apps/frontend"}},c=[{value:"Purpose",id:"purpose",children:[]},{value:"<code>ChainInterface</code>",id:"chaininterface",children:[]},{value:"<code>KeySource</code>",id:"keysource",children:[]},{value:"&quot;Infer&quot; types",id:"infer-types",children:[]}],l={toc:c};function p(e){var n=e.components,t=(0,i.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"purpose"},"Purpose"),(0,r.kt)("p",null,"In order to stay sane and productive when integrating many blockchains into a single project, we need to be able to decouple each integration from core wallet functionality as much as possible. Every chain worth integrating has its own SDK, which we should use in order to avoid re-inventing wheels. However, a separate SDK for each chain means separate types and interfaces for public keys, secret keys, key pairs, RPC calls, transactions, transaction signing, transaction sending, accounts, account metadata, and more, not to mention the fact that they are often object-orented and thus ",(0,r.kt)("em",{parentName:"p"},"stateful"),", each in their own particular way. To not isolate all of this from our core functionality would quickly result in an epidemic of fugly code that's incredibly difficult to work with spreading across the BAF Wallet codebase."),(0,r.kt)("p",null,"In order to do this, we need some well-chosen unifying types and interfaces that abstract over the specific chain implementations - this is the purpose of ",(0,r.kt)("inlineCode",{parentName:"p"},"@baf-wallet/interfaces"),"."),(0,r.kt)("h2",{id:"chaininterface"},(0,r.kt)("inlineCode",{parentName:"h2"},"ChainInterface")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ChainInterface")," is by far the most complicated of the unifying interfaces supplied by ",(0,r.kt)("inlineCode",{parentName:"p"},"@baf-wallet/interfaces"),". Take a gander at it. Totally understandable if it seems overwhelming - just know that it's defined in such a matter that 99% of the time you should never have to use it in a way that is overwhelming."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="libs/interfaces/src/lib/chains.ts"',title:'"libs/interfaces/src/lib/chains.ts"'},"export interface ChainInterface<\n  PK,\n  SK,\n  KP,\n  InitParams,\n  Inner,\n  Tx,\n  BuildTxParams,\n  SignedTx,\n  SignOpts,\n  SendOpts,\n  SendResult,\n  Account,\n  AccountLookupParams,\n  AccountCreateParams\n> {\n  rpc: (innerSdk: Inner) => RpcInterface<Tx, SignedTx, SendOpts, SendResult>;\n  tx: (\n    innerSdk: Inner\n  ) => TxInterface<Tx, BuildTxParams, SignedTx, SignOpts, SendOpts, SendResult>;\n  accounts: (\n    innerSdk: Inner\n  ) => AccountsInterface<Account, AccountLookupParams, AccountCreateParams>;\n  init: (params: InitParams) => Promise<Inner>;\n  convert: Converter<PK, SK, KP>;\n}\n")),(0,r.kt)("p",null,"At a high level, ",(0,r.kt)("inlineCode",{parentName:"p"},"ChainInterface")," is a generic interface with a lot of type parameters whose properties refer to sub-interfaces dedicated to a particular subset of chain-specific functionality - ",(0,r.kt)("inlineCode",{parentName:"p"},"RpcInterface")," for RPC calls, ",(0,r.kt)("inlineCode",{parentName:"p"},"TxInterface")," for transactions, ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountsInterface")," for accounts, and ",(0,r.kt)("inlineCode",{parentName:"p"},"init")," for any necessary initialization steps."),(0,r.kt)("p",null,"Many of the type parameters can described as the chain-specific types for common things needed for interacting with a blockchain - for instance ",(0,r.kt)("inlineCode",{parentName:"p"},"PK")," is the underlying implementations public key type, and ",(0,r.kt)("inlineCode",{parentName:"p"},"SK"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"KP"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Tx")," similarly for secret keys, key pairs, and transactions. The only one that really warrants explanation is ",(0,r.kt)("inlineCode",{parentName:"p"},"Inner"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Inner"),' is a type that that must contain all "state" required by the underlying implementation - this includes all values that can change as a side effect of an operation and serves to allow us to separate state from execution, making our code much more flexible and easy to use in many different contexts. Typically, this will be an instance of the top-level class exposed by an object-oriented SDK. Sometimes the implementor of the BAF Wallet wrapper for that SDK might wish to include other values as well.'),(0,r.kt)("p",null,"You might have noticed that the ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tx"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"accounts")," properties of ",(0,r.kt)("inlineCode",{parentName:"p"},"ChainInterface")," are actually functions that take an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Inner")," and return the relevant interfaces. This is how we separate state from execution - the actual code for implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"ChainInterface")," is a function that, given the state, performs the desired operation and updates the state. This has the benefit that you can use a different value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Inner")," at different times but still use the same code, which allows for much more flexible code that makes it easy to tell when side effects occurr and where the state they change is."),(0,r.kt)("p",null,"That being said, for a majority of use cases having the state bundled together with the actual implementation is more than fine and makes things simple. This is where ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedChainInterface")," comes in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="libs/interfaces/src/lib/chains.ts"',title:'"libs/interfaces/src/lib/chains.ts"'},"export interface WrappedChainInterface<\n  PK,\n  SK,\n  KP,\n  Inner,\n  Tx,\n  BuildTxParams,\n  SignedTx,\n  SignOpts,\n  SendOpts,\n  SendResult,\n  Account,\n  AccountLookupParams,\n  AccountCreateParams\n> {\n  rpc: RpcInterface<Tx, SignedTx, SendOpts, SendResult>;\n  tx: TxInterface<Tx, BuildTxParams, SignedTx, SignOpts, SendOpts, SendResult>;\n  accounts: AccountsInterface<\n    Account,\n    AccountLookupParams,\n    AccountCreateParams\n  >;\n  convert: Converter<PK, SK, KP>;\n  getInner: () => Inner;\n}\n")),(0,r.kt)("p",null,"as you can see, ",(0,r.kt)("inlineCode",{parentName:"p"},"WrappedChainInterface")," is exactly the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"ChainInterface"),", but the functions have already been called for you, all using a single instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Inner"),". Then we also provide a function in ",(0,r.kt)("inlineCode",{parentName:"p"},"@baf-wallet/multi-chain")," that takes does exactly this."),(0,r.kt)("h2",{id:"keysource"},(0,r.kt)("inlineCode",{parentName:"h2"},"KeySource")),(0,r.kt)("p",null,"TODO"),(0,r.kt)("h2",{id:"infer-types"},'"Infer" types'),(0,r.kt)("p",null,"TODO"))}p.isMDXComponent=!0}}]);